<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Problems with Python's subprocess.communicate method</title>
    <meta name="author" content="Douglas Creager" />
 
    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

    <!-- main CSS -->
    <link rel="stylesheet" href="/css/main.css" type="text/css" />
  </head>

  <body>

    <div class="site">
      <div class="site_content">
        <div class="left">
          <div class="leftnav">
            <p><a href="/">Home</a></p>
<p><a href="/publications/">Publications</a></p>

          </div>
        </div>

        <div class="body">
          
<div class="post">
  <h1 id='problems_with_pythons_subprocesscommunicate_method'>Problems with Python&#8217;s subprocess.communicate method</h1>

<p>The <a href='http://docs.python.org/library/subprocess.html'><code>subprocess</code></a> module, which was introduced in Python 2.4, provides you with a convenient interface for spawning <em>subprocesses</em>, and for interacting with these subprocesses in your parent process. The module was introduced in <a href='http://www.python.org/dev/peps/pep-0324/'>PEP 324</a>, and is a replacement for the proliferation of other functions and modules that were used previously for spawning and interacting with processes. The <code>subprocess</code> module aims to provide a more consistent interface, regardless of the particulars of how you need to interact with the subprocesses.</p>

<h2 id='overview_of_the__module'>Overview of the <code>subprocess</code> module</h2>

<p>Subprocesses are encapsulated in a <code>Popen</code> object. You interact with a subprocess via its stdin, stdout, and stderr streams. When you create a new <code>Popen</code> object, you can give a value of <code>PIPE</code> for the <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> keyword parameters. If you do, then the <code>Popen</code> object that you get back will have <code>stdin</code>, <code>stdout</code>, and/or <code>stderr</code> attributes. Each of these is a file-like object, giving you access to the corresponding stream of the subprocess.</p>

<p>Now, you have to be careful how you use these pipe objects, since it&#8217;s easy to fall into a situation where you have deadlock. For instance, your parent process might be trying to write some data into the <code>stdin</code> pipe, to send some information into the subprocess. The subprocess, on the other hand, is trying to write some data into the <code>stdout</code> pipe, to send some information back out to the parent process. If the <code>stdout</code> pipe&#8217;s buffer is full, then the subprocess will block trying write into the pipe; it won&#8217;t be able to proceed until the parent process has read some data from the <code>stdout</code> pipe, clearing room in the buffer for the new data. However, the parent process is currently trying to write into the <code>stdin</code> pipe. If this write is also blocked, then we have deadlock — neither process can proceed.</p>

<h2 id='the__method'>The <code>communicate</code> method</h2>

<p>The usual solution in these cases is to use the <code>Popen</code> object&#8217;s <code>communicate</code> method. This method takes in an optional string to send to the subprocess on stdin. It then collects all of the stdout and stderr output from the subprocess, and returns these. The <code>communicate</code> method takes responsibility for avoiding deadlock; it only sends the next chunk of the stdin string when the subprocess is ready to read it, and it only tries to read the next chuck of stdout or stderr when the subprocess is ready to provide it.</p>

<p>Under the covers, the <code>communicate</code> method uses a <code>select</code> loop to perform this choreography with the subprocess. (At least for the Unix implementation of the <code>subprocess</code> module, that is.) This solution is nice because it doesn&#8217;t require introducing threading into the parent process. During each iteration of the loop, it calls the OS&#8217;s <code>select</code> system call, giving it the file descriptors of the stdin, stdout, and stderr pipes. The <code>select</code> call tells us which of these file descriptors can perform an I/O operation without blocking. If none of them can immediately, it will block until one of them can. Once the <code>select</code> call returns, we read from or write to the pipes that are ready. We repeat this process until we see EOF on both stdout and stderr; this indicates that the subprocess has finished — or at least, that it&#8217;s through communicating with us.</p>

<h2 id='drawbacks'>Drawbacks</h2>

<p>The <code>communicate</code> method provides a nice, simple interface for interacting with a subprocess, without having to worry about deadlock situations. Unfortunately, it has two main drawbacks:</p>

<ul>
<li>The subprocess&#8217;s stdout and stderr are collected into strings.</li>

<li>You can only interact with one subprocess at a time.</li>
</ul>

<p>(If neither of these is an issue for you, then the rest of this post is less interesting to you — <code>communicate</code> does exactly what you want!)</p>

<p>The first item is a problem if your subprocess creates a lot of output — the worry is the output will be too large to fit into a Python string. If it is, then the parent process will (at best) start to thrash as it eats into virtual memory.</p>

<p>The second item is a problem if you have to spawn multiple subprocesses, and interact with them simultaneously. You could argue that there&#8217;s no need to fix this problem if you haven&#8217;t fixed the first: since the <code>communicate</code> method is just going to collect the stdout and stderr into strings, then you could just loop through each of your subprocesses, calling <code>communicate</code> on each in turn:</p>
<div class='highlight'><pre><span class='kn'>import</span> <span class='nn'>subprocess</span>

<span class='n'>sp1</span> <span class='o'>=</span> <span class='n'>subprocess</span><span class='o'>.</span><span class='n'>Popen</span><span class='p'>([</span><span class='s'>&quot;ls&quot;</span><span class='p'>,</span> <span class='s'>&quot;-l&quot;</span><span class='p'>],</span>
                       <span class='n'>stdin</span><span class='o'>=</span><span class='n'>subprocess</span><span class='o'>.</span><span class='n'>PIPE</span><span class='p'>,</span>
                       <span class='n'>stdout</span><span class='o'>=</span><span class='n'>subprocess</span><span class='o'>.</span><span class='n'>PIPE</span><span class='p'>)</span>

<span class='n'>sp2</span> <span class='o'>=</span> <span class='n'>subprocess</span><span class='o'>.</span><span class='n'>Popen</span><span class='p'>([</span><span class='s'>&quot;ls&quot;</span><span class='p'>,</span> <span class='s'>&quot;-al&quot;</span><span class='p'>],</span>
                       <span class='n'>stdin</span><span class='o'>=</span><span class='n'>subprocess</span><span class='o'>.</span><span class='n'>PIPE</span><span class='p'>,</span>
                       <span class='n'>stdout</span><span class='o'>=</span><span class='n'>subprocess</span><span class='o'>.</span><span class='n'>PIPE</span><span class='p'>)</span>

<span class='k'>for</span> <span class='n'>sp</span> <span class='ow'>in</span> <span class='p'>[</span><span class='n'>sp1</span><span class='p'>,</span> <span class='n'>sp2</span><span class='p'>]:</span>
    <span class='p'>(</span><span class='n'>stdout</span><span class='p'>,</span> <span class='n'>stderr</span><span class='p'>)</span> <span class='o'>=</span> <span class='n'>sp</span><span class='o'>.</span><span class='n'>communicate</span><span class='p'>()</span>
    <span class='k'>print</span> <span class='n'>stdout</span>
</pre>
</div>
<p>The end result would be what you want — all of the stdout and stderr strings for all of your subprocesses.</p>

<p>However, doing so can make your subprocesses take longer to run, since you won&#8217;t be able to exploit parallelism as much. Since you&#8217;re firing off these subprocesses at the same time, you supposedly want them to execute simultaneously, allowing the OS to schedule them appropriate so that they finish as quickly as possible. However, you&#8217;ve introduced a serialization into this logic, since your parent process is only able to interact with one subprocess at a time. For instance, subprocess #2 might be waiting for some input, while the parent process is still snarfing up the output from subprocess #1. In this case, subprocess #2 is <strong><em>not going to be able to start executing</em></strong> until subprocess #1 has <strong><em>completely finished</em></strong>. So your <code>communicate</code> loop has completely eliminated the benefit of starting the subprocesses simultaneously.</p>

<p>In later posts, I will outline how to solve these two problems.</p>
</div>

<div class="postdate">
  Last updated on Thursday, August 06, 2009
</div>

        </div>

        

        <div class="body_separator"></div>

        <div class="body">
          <div id="disqus_thread"></div>

          <script type="text/javascript">
            var disqus_developer = true;
          </script>

          <script
             type="text/javascript"
             src="http://disqus.com/forums/dcreager/embed.js">
          </script>
          <noscript>
            <a href="http://dcreager.disqus.com/?url=ref">View the discussion thread.</a>
          </noscript>

          <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>

        

      </div>
    </div>

    <div class="footer">
      <div class="copyright">
        Copyright © 2009, Douglas Creager.  All rights reserved.
      </div>
    </div>

  </body>
</html>

