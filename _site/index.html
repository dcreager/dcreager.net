<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>dcreager.net</title>
    <meta name="author" content="Douglas Creager" />

    <meta name="google-site-verification" content="7KIoYPNsfdDxIdX1QQ7SM2Nm_nyy13aRlDkzE3wzhhY" />

    
    <link rel="openid.server" href="http://openid.dcreager.net/index.php" />
    <link rel="openid.delegate" href="http://openid.dcreager.net/index.php" />
    

    <link rel="alternate" type="application/atom+xml"
          title="dcreager.net" href="/atom.xml"/>
 
    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

    <!-- main CSS -->
    <link rel="stylesheet" href="/css/main.css" type="text/css" />

    <!-- Cufon -->
    <script src="/js/jquery-1.4.1.min.js" type="text/javascript"></script>
    <script src="/js/cufon-yui.js" type="text/javascript"></script>
    <script src="/js/Delicious.js" type="text/javascript"></script>
    <script src="/js/Junction.js" type="text/javascript"></script>
    <script src="/js/Tagesschrift.js" type="text/javascript"></script>

    <script type="text/javascript">
      Cufon.replace('.body h1', { fontFamily: 'Delicious' });
      Cufon.replace('.body h2', { fontFamily: 'Delicious' });
      Cufon.replace('.body h3', { fontFamily: 'Delicious' });
      Cufon.replace('.body .postdate', { fontFamily: 'Junction' });
      Cufon.replace('.site_header .title', { fontFamily: 'Tagesschrift' });
      Cufon.replace('.site_header .subtitle', { fontFamily: 'Junction' });
    </script>
  </head>

  <body>

    <!--
       Preload some images.  The “preload” class is set to never
       display.
      -->
    <div class="preload">
      <img src="/images/icon-pdf.png"/>
      <img src="/images/icon-pdf-shadow.png"/>
      <img src="/images/mag.png"/>
      <img src="/images/mag-shadow.png"/>
    </div>

    <div class="site">
      <div class="site_content">
        <div class="left">
          <div class="leftnav">
            <h3><a href="/">Home</a></h3>
<h3><a href="/about/">About</a></h3>
<h3><a href="/archive/">Archive</a></h3>
<h3><a href="/publications/">Publications</a></h3>

          </div>
        </div>

        <div class="site_header">
          <h1 class="title">dcreager.net</p>
          <h2 class="subtitle">a blog about huge data, coding, and miscellanea</p>
        </div>

        <div class="content">

        <div class="body">
          
  

  <h1>Installing Ubuntu Lucid on a PowerPC QEMU virtual machine</h1>

  <div class="postdate">
    Thursday, May 13, 2010
  </div>

  <p>Part of the software I help develop at <a href='http://www.redjack.com/'>RedJack</a> needs to be tested on both little-endian and big-endian machines. Little-endian machines are easy, since everyone and their mother is running on a little-endian Intel or AMD x86 chip. It used to be that big-endian was pretty easy to test, too — just break out your trusty Apple Powerbook G4 and you&#8217;re good to go. Since Apple has shifted over to Intel chips, though, the situation has changed.</p>

<p>Luckily, <a href='http://wiki.qemu.org/'>QEMU</a> has PowerPC as one of the targets that it can emulate, so in theory, I can still easily test my code on a big-endian machine by creating a QEMU PowerPC virtual machine. There&#8217;s already a writeup about trying to install Debian onto a QEMU VM <a href='http://machine-cycle.blogspot.com/2009/05/running-debian-on-qemu-powerpc.html'>here</a>. <a href='http://www.aurel32.net/'>Aurélien Jarno</a> has graciously put together downloadable disk images with Debian preinstalled. If that&#8217;s good enough for your purposes, just go download those! You won&#8217;t need any of the rest of the information on this page.</p>

<p>Unfortunately, I didn&#8217;t want to run stock Debian; my little-endian build machine is running Ubuntu Lucid, and for consistency, I wanted my big-endian VM to be running the same. As it turns out, this also required a fair dose of masochism on my part. There are several issues that you&#8217;ll encounter if you try to do this by hand. Here is my cheat sheet for getting around these issues.</p>

<p>Note that this isn&#8217;t a full step-by-step account of how to install Lucid onto a QEMU VM. For now, I&#8217;m just trying to get my notes down into a more permanent form.</p>

<h2 id='getting_qemu'>Getting QEMU</h2>

<p>Note that I&#8217;m using Ubuntu Lucid as both the host and the guest OS for this virtual machine; if you&#8217;re running QEMU on a non-Ubuntu host, then you can skip this section.</p>

<p>It seems that there&#8217;s a bug with the current QEMU packages in Lucid. If you try to run <code>qemu-system-ppc</code>, you&#8217;ll get an error message about missing the PowerPC BIOS image. Joy.</p>

<p>Easiest way to get around this is to install QEMU from source. Download the latest version from <a href='http://download.savannah.gnu.org/releases/qemu/'>here</a>. Once you&#8217;ve unpacked it, use the following to build:</p>

<pre><code>$ sudo apt-get build-dep qemu
$ ./configure --prefix=/usr/local \
    --enable-sdl --enable-curses --enable-curl \
    --enable-kvm --enable-nptl --enable-uuid \
    --enable-linux-aio --enable-io-thread \
    --audio-drv-list=alsa
$ make
$ sudo make install</code></pre>

<p>The first command is just an easy way to ensure that all of the prerequisite libraries are installed.</p>

<h2 id='booting_the_installation_cd'>Booting the installation CD</h2>

<p>Once you&#8217;ve got a working QEMU installed, you can find the PowerPC Lucid installation CD <a href='http://cdimage.ubuntu.com/ports/releases/10.04/release/'>here</a>. I&#8217;ve decided to use the server installation CD; I don&#8217;t really need (or want) X windows running in the VM.</p>

<p>To install this onto a new VM, it should be as simple as:</p>

<pre><code>$ qemu-img create -f qcow2 ubuntu-ppc.qcow2 10G
$ qemu-system-ppc -m 1024 -hda ubuntu-ppc.qcow2 \
    -cdrom ubuntu-10.04-server-powerpc.iso -boot d</code></pre>

<p>This links up the Ubuntu installation CD on the VM&#8217;s CD-ROM drive, and uses a new disk image for the primary hard disk. Oh, and we make sure to give the VM enough RAM to do its business — the default is a paltry 128MB.</p>

<p>Of course, this doesn&#8217;t work — the Lucid installer suffers from the same problem described <a href='http://mac.linux.be/content/ubuntu-810-installer-fails-detect-cd-rom'>here</a> for the Intrepid installer. Once you get into the installer, the installation program can&#8217;t find the CD-ROM device, and so it can&#8217;t read the installation packages. Unfortunately, the workaround doesn&#8217;t work for Lucid, since it uses a newer Linux kernel that has <a href='http://www.linux.com/archive/feed/33164'>eliminated the <code>ide-scsi</code> module</a>.</p>

<p>So, what do we do? Well, QEMU also allows us to mount a disk image as a USB removable disk, but it won&#8217;t let us boot from USB. We end up having to mount the disk image twice: Once as a virtual CD, so that we can boot into the installer, and once as a virtual USB disk, so that the installer can find the installation packages. The QEMU command line becomes:</p>

<pre><code>$ qemu-system-ppc -m 1024 -hda ubuntu-ppc.qcow2 \
    -cdrom ubuntu-10.04-server-powerpc.iso -boot d \
    -usb -usbdevice disk:ubuntu-10.04-server-powerpc.iso</code></pre>

<p>You won&#8217;t have to manually load the <code>usb-storage</code> module; it gets loaded automatically, and places the USB disk at <code>/dev/sda</code>.</p>

<p>You&#8217;ll still get the error message about not finding the CD; when this happens say &#8220;no&#8221; when it asks whether you need to load a module from a removable disk. Say &#8220;yes&#8221; when it asks if you want to choose a module and device manually; choose &#8220;none&#8221; for the module; then type in <code>/dev/sda</code> as the device location.</p>

<h2 id='corrupt_package_files_on_cd'>Corrupt package files on CD</h2>

<p>Right, so now we have to be good, right? We can start QEMU, we can boot into the installer, and the installer can find all of the packages? Nope! There were several corrupted package files on the CD image I downloaded. If this happens to you, you should certainly try re-downloading the image, to take care of any spurious transmission errors. But if you still end up with some corrupted package files, there are ways around it.</p>

<p>The installer will try to install its initial set of packages using <code>apt-get</code>. If you encounter problems with these stages, you&#8217;ll see some informative error messages on console 4, which is where the installer&#8217;s log output is sent. You can get there by pressing <em>Alt-F4</em> in the VM. (As a warning, don&#8217;t try to shift to console 4 without ensuring that QEMU is grabbing the input. In most window managers, <em>Alt-F4</em> will close the current window, which will just abruptly stop the VM!)</p>

<p>By the time the installer tries to install packages, the VM&#8217;s hard disk will be partitioned and formatted, and so we can drop into a shell as necessary. To do so, shift over to console 2 using <em>Alt-F2</em> — again, make sure that QEMU is grabbing all keyboard and mouse input before switching consoles.</p>

<p>Once you&#8217;re on console 2, you can <code>chroot</code> into the new system as follows:</p>

<pre><code>~ $ mount -o /proc /target/proc
~ $ mount -o /sys /target/sys
~ $ mount -o /dev /target/dev
~ $ chroot /target</code></pre>

<p>At this point, you&#8217;ll be &#8220;inside&#8221; the new installation system, and can run whatever <code>apt-get</code> and <code>dpkg</code> commands are necessary to fix things up.</p>

<p>Most likely, you&#8217;ll see &#8220;hash sum mismatch&#8221; errors, indicating that a package file is corrupt. You need to download the correct version from the archive at <em>ports.ubuntu.com</em>. To do this, you&#8217;ll need a copy of <em>wget</em> installed.</p>

<pre><code>$ apt-get install wget
$ wget -nv http://ports.ubuntu.com/pool/main/PATH_TO_DEB</code></pre>

<p>You&#8217;ll see what to use for the <code>PATH_TO_DEB</code> part in the error message. Once you&#8217;ve downloaded all of the troublesome package files, install them using:</p>

<pre><code>$ dpkg -i *.deb
$ apt-get -f install</code></pre>

<p>Then you can go back into the installer (on console 1) and try to repeat the current step.</p>

<p>Note that things might be broken early enough that you can&#8217;t install <em>wget</em>. If this is the case, how do you download the non-corrupt package file? Luckily, Python was already installed at that point, so you can use the Python standard library to <a href='http://stackoverflow.com/questions/22676/how-do-i-download-a-file-over-http-using-python'>emulate <em>wget</em></a>:</p>

<pre><code>$ python
&gt;&gt;&gt; import urllib2
&gt;&gt;&gt; pkg = urllib2.urlopen(&quot;http://ports.ubuntu.com/BLAH_BLAH&quot;)
&gt;&gt;&gt; output = open(&quot;BLAH_BLAH.deb&quot;, &quot;wb&quot;)
&gt;&gt;&gt; output.write(pkg.read())
&gt;&gt;&gt; output.close()
&gt;&gt;&gt; ^D</code></pre>

<p>You can then install the package as above.</p>

<h2 id='installing_a_bootloader'>Installing a bootloader</h2>

<p>The installer claims that this architecture doesn&#8217;t support a bootloader, so we have to install one by hand. The usual bootloader for PowerPC machines is <code>yaboot</code>; it&#8217;s fair</p>

  
  <div class="posttags">
    Tags:
    <ul>
      
      <li><a href="/tags/ubuntu/">ubuntu</a></li>
      
    </ul>
  </div>
  

  <div class="postlinks">
    <a href="/2010/05/13/powerpc-qemu-lucid/">Permanent link</a>
    |
    <a href="/2010/05/13/powerpc-qemu-lucid/#disqus_thread">Comments</a>
  </div>

  
  </div>
<div class="body_separator"></div>
<div class="body">

  

  <h1>Parser callbacks in libpush, Part 1 — Streams</h1>

  <div class="postdate">
    Thursday, February 25, 2010
  </div>

  <p>This post is the first in a series that describes the <code>push_callback_t</code> type in the <a href='http://github.com/dcreager/libpush/'>libpush</a> library. In these posts, we&#8217;ll walk through a couple of possible ways to implement callbacks under the covers. At each stage, we&#8217;ll encounter problems with the current design. Fixing these problems should lead closer us to the actual implementation in libpush, and along the way, we&#8217;ll gain a good understanding of how our design decisions affect the performance and usability of the library.</p>

<p>The <code>push_callback_t</code> type is used to define <em>parser callbacks</em>, which are the basic unit of parsing in libpush. Callbacks are pretty simple: they take in an <em>input value</em>, read some data from the <em>input stream</em>, and produce an <em>output value</em>. (The fact that callbacks take in an input value, in addition to reading from the input stream, is what makes them <a href='http://www.haskell.org/arrows/'><em>arrows</em></a> instead of <a href='http://en.wikipedia.org/wiki/Monad_%28functional_programming%29'><em>monads</em></a> — but that&#8217;s a story for a later post).</p>

<h2 id='first_attempt_callbacks_as_functions'>First attempt: Callbacks as functions</h2>

<p>Now, with this simple structure, we might try to implement callbacks as regular C functions. For instance, we could use something like the following to read in a single 32-bit integer:</p>
<div class='highlight'><pre><code class='c'><span class='cp'>#include &lt;stdbool.h&gt;</span>
<span class='cp'>#include &lt;stdint.h&gt;</span>
<span class='cp'>#include &lt;stdio.h&gt;</span>

<span class='n'>bool</span>
<span class='nf'>parse_uint32</span><span class='p'>(</span><span class='kt'>void</span> <span class='o'>*</span><span class='n'>input</span><span class='p'>,</span> <span class='kt'>uint32_t</span> <span class='o'>*</span><span class='n'>output</span><span class='p'>,</span> <span class='kt'>FILE</span> <span class='o'>*</span><span class='n'>stream</span><span class='p'>)</span>
<span class='p'>{</span>
    <span class='kt'>size_t</span>  <span class='n'>num_read</span><span class='p'>;</span>

    <span class='n'>num_read</span> <span class='o'>=</span> <span class='n'>fread</span><span class='p'>(</span><span class='n'>output</span><span class='p'>,</span> <span class='k'>sizeof</span><span class='p'>(</span><span class='kt'>uint32_t</span><span class='p'>),</span> <span class='mi'>1</span><span class='p'>,</span> <span class='n'>stream</span><span class='p'>);</span>
    <span class='k'>return</span> <span class='p'>(</span><span class='n'>num_read</span> <span class='o'>==</span> <span class='mi'>1</span><span class='p'>);</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>This callback ignores its input value, reads in four bytes from the input stream, and uses that to output a <code>uint32_t</code> value. The return value of the function is a boolean, indicating whether the parse was successful or not. This lets us handle <em>parse errors</em> — for instance, if there are only three bytes left in the stream, we can&#8217;t read in a full integer. We return <code>false</code> to indicate this error condition.</p>

<p>We&#8217;ve ignored some details here that aren&#8217;t important for this example — for instance, we don&#8217;t worry about the endianness of the integer, nor do we worry about how the space for the output result is allocated. We just assume that someone will pass in a pointer to a <code>uint32_t</code> variable, and our callback function will store its output value there.</p>

<h2 id='drawbacks'>Drawbacks</h2>

<p>This approach works fine for simple cases, but unfortunately has two drawbacks. First, we&#8217;re limited to parsing from <code>FILE</code> streams. Any real input source will probably be available as a stream, so this might not seem like a huge problem — though it does rule out parsing from a memory buffer, unless you use a non-portable function like <code>fmemopen</code>.</p>

<p>The second, more important, problem is that the parser callback has full control over when and how much to read from the stream. In this example, we try to read in the full four bytes for the <code>uint32_t</code> output value. However, there might not be four bytes available in the stream. If this is because we&#8217;re at the end of a file, then we should treat this as a parse error. If we&#8217;re reading from a network socket, though, another chunk of data might arrive if we wait for a bit.</p>

<p>We could add logic to the callback to read from the stream repeatedly until we got enough data, but then we&#8217;ll start <em>blocking</em> — so that we can distinguish between &#8220;there&#8217;s no more data here <em>yet</em>&#8221; from &#8220;there&#8217;s no more data coming <em>at all</em>&#8221;.</p>

<p>All of this is bad news. First of all, this extra I/O logic is starting to get rather big, and we don&#8217;t want each and every callback to have to include it. And second, we don&#8217;t want the rest of our program to be held hostage by the callback — it should be up to our I/O code to decide whether it&#8217;s okay to block waiting for more input, or whether to whip up a nice <code>select</code> loop of some kind to read things more efficiently.</p>

<p>In the next post, we&#8217;ll describe <em>iteratees</em>, which give us this capability.</p>

  
  <div class="posttags">
    Tags:
    <ul>
      
      <li><a href="/tags/libpush/">libpush</a></li>
      
      <li><a href="/tags/c/">c</a></li>
      
    </ul>
  </div>
  

  <div class="postlinks">
    <a href="/2010/02/25/libpush-callbacks-part-1/">Permanent link</a>
    |
    <a href="/2010/02/25/libpush-callbacks-part-1/#disqus_thread">Comments</a>
  </div>

  
  </div>
<div class="body_separator"></div>
<div class="body">

  

  <h1>Using LLVM's link-time optimization on Ubuntu Karmic</h1>

  <div class="postdate">
    Wednesday, February 17, 2010
  </div>

  <p>While playing around with <a href='http://github.com/dcreager/libpush'>libpush</a> on my MacBook, I was pleasantly surprised to see a huge performance increase when I used the link-time optimization (LTO) feature of the LLVM GCC front end. (It&#8217;s really quite nifty; the new <a href='http://github.com/mxcl/homebrew'>Homebrew package manager</a> uses it by default when compiling packages.) On MacOS, using LTO is as simple as using <code>llvm-gcc</code> as your C compiler (or <code>llvm-g++</code> if you&#8217;re compiling C++), and passing in <code>-O4</code> as your optimization flag. I use SCons as my builder, so this turns into:</p>

<pre><code>$ scons CC=llvm-gcc CCFLAGS=-O4</code></pre>

<p>This will cause GCC to output LLVM bytecode into the <em>.o</em> output files, and to perform whole-program optimizations during each linking phase. I was able to see a big performance win simply from the linker being able to inline in copies of small functions that live in “other” compilation units.</p>

<h2 id='good_news_and_bad_news'>Good news and bad news</h2>

<p>Intrigued by the results, I wanted to try the same thing on my Linux boxes, which are running Ubuntu Karmic. On the Mac, Apple has made sure to include support for LLVM in all of the standard Xcode build tools. On Linux, you don&#8217;t get this by default right now — though GCC is implementing their own LTO project, which is starting to bear fruit. Part of this is a new “<code>gold</code>” linker, which supports a plugin architecture. How is this useful to us? Well, LLVM already has a <a href='http://llvm.org/docs/GoldPlugin.html'>plugin</a> for the new linker, so with everything installed correctly, getting LTO through LLVM on Linux can be just as simple as it was on the Mac.</p>

<p>Unfortunately, these new tools have only partially made it into the Ubuntu package tree. You can get the new <code>gold</code> linker by installing the <code>binutils-gold</code> package, and you can get most of the LLVM pieces by installing the <code>llvm</code> and <code>llvm-gcc-4.2</code> packages. Unfortunately, this doesn&#8217;t include the LLVM <code>gold</code> plugin or the new <code>clang</code> C/C++ compiler front-end. Things look promising for these features being in the new Lucid packages — which could even lead to a Karmic backport — but for now, if we want the <code>gold</code> plugin, we have to compile ourselves.</p>

<h2 id='getting_the_prerequisites'>Getting the prerequisites</h2>

<p>As mentioned on the LLVM <a href='http://llvm.org/docs/GoldPlugin.html'>linker plugin page</a>, you need to have the <code>binutils</code> source lying around somewhere if you want to compile the plugin, since the LLVM source needs to read in <code>binutils</code>&#8217;s <em>plugin-api.h</em> file. The easiest way for us to get the <code>binutils</code> source is using APT:</p>

<pre><code>$ mkdir -p $HOME/deb
$ cd $HOME/deb
$ apt-get source binutils</code></pre>

<p>This will place an unpacked copy of the <code>binutils</code> source into <em>$HOME/deb/binutils-2.20</em> for you.</p>

<p>We can also go ahead and install the <code>gold</code> linker:</p>

<pre><code>$ sudo apt-get install binutils-gold</code></pre>

<p>You&#8217;ll also need to make sure you&#8217;ve got the basic compilation tools installed (though if you&#8217;re at the point where you&#8217;re trying to play around with LTO, I&#8217;ve got to assume you&#8217;ve already taken care of this&#8230;):</p>

<pre><code>$ sudo apt-get install build-essential</code></pre>

<p>Finally, my main Linux box is 64-bit, so I need to install multilib support before we can compile the LLVM GCC front end:</p>

<pre><code>$ sudo apt-get install gcc-multilib</code></pre>

<h2 id='compiling_llvm'>Compiling LLVM</h2>

<p>With all of the prerequisites installed, we can download and unpack LLVM:</p>

<pre><code>$ mkdir -p $HOME/tmp
$ cd $HOME/tmp
$ wget http://llvm.org/releases/2.6/llvm-2.6.tar.gz
$ wget http://llvm.org/releases/2.6/clang-2.6.tar.gz

$ tar xzvf llvm-2.6.tar.gz
$ tar xzvf clang-2.6.tar.gz</code></pre>

<p><code>clang</code> is distributed as a separate download, but we actually want to place it into the main LLVM directory; the LLVM build scripts will find it and build it automatically:</p>

<pre><code>$ mv clang-2.6 llvm-2.6/tools/clang</code></pre>

<p>At this point we can do the usual compilation steps:</p>

<pre><code>$ cd llvm-2.6
$ ./configure \
    --with-binutils-include=$HOME/deb/binutils-2.20/include \
    --enable-optimized \
    --prefix=/usr/local
$ make
$ sudo make install
$ sudo ldconfig</code></pre>

<p>Notice how we&#8217;re going to install everything into <em>/usr/local</em>, so as not to step on the toes of the package manager. This means we have to run <code>ldconfig</code> so that the system linker knows about the new libraries we just put in <em>/usr/local/lib</em>.</p>

<h2 id='compiling_llvmgcc'>Compiling LLVM-GCC</h2>

<p>At this point, we have the <code>gold</code> linker installed, and have a copy of LLVM that includes its <code>gold</code> plugin. Ideally, we could start compiling with <code>clang</code> and get LTO, but it doesn&#8217;t seem like there&#8217;s currently a way to have <code>clang</code> pass in the necessary <code>--plugin</code> option to the linker. So, all we need now is the GCC front end.</p>

<p>As before, we start by downloading and unpacking:</p>

<pre><code>$ cd $HOME/tmp
$ wget http://llvm.org/releases/2.6/llvm-gcc-4.2-2.6.source.tar.gz
$ tar xzvf llvm-gcc-4.2-2.6.source.tar.gz</code></pre>

<p>The <em>README.LLVM</em> file in the source tree gives more detail on the options you have available; for me, the following worked:</p>

<pre><code>$ mkdir -p $HOME/tmp/obj
$ cd $HOME/tmp/obj
$ ../llvm-gcc-4.2-2.6.source/configure \
    --prefix=/usr/local \
    --program-prefix=llvm- \
    --enable-llvm=$HOME/tmp/llvm-2.6 \
    --enable-languages=c,c++
$ make
$ sudo make install
$ sudo ldconfig</code></pre>

<p>The only interesting wrinkle is that we have to do an out-of-source build — the object files will end up in the <em>$HOME/tmp/obj</em> directory, rather than being created directly in the unpacked source directory.</p>

<p>As this point we&#8217;re nearly there; we have <code>llvm-gcc</code> installed, but its <code>-use-gold-plugin</code> option won&#8217;t work just yet. If you look closely at one sentence on the <a href='http://llvm.org/docs/GoldPlugin.html'>LLVM plugin page</a>, you&#8217;ll see that the option “looks for the <code>gold</code> plugin in the same directories as it looks for <code>cc1</code>”. The LLVM GCC package installed the <code>cc1</code> program into the <em>/usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.2.1</em> directory. (The <em>x86_64</em> will be different if you&#8217;re on a different architecture.) However, the LLVM plugin is in <em>/usr/local/lib</em>. If you try to use the <code>-use-gold-plugin</code> parameter, you&#8217;ll get the following error message:</p>

<pre><code>$ llvm-gcc -use-gold-plugin \
    -o foo.o -c -O4 -g -Wall -Werror foo.c
llvm-gcc: -use-gold-plugin, but libLLVMgold.so not found.</code></pre>

<p>Not good. The solution (which is admittedly a bit of a hack) is to copy the plugin into the directory that <code>llvm-gcc</code> expects to find it in:</p>

<pre><code>$ sudo cp /usr/local/lib/libLLVMgold.so \
    /usr/local/libexec/gcc/x86_64-unknown-linux-gnu/4.2.1</code></pre>

<h2 id='using_your_new_toy'>Using your new toy</h2>

<p>Now that we&#8217;ve got all of the pieces installed, you can create libraries and executables that are optimized at link time. The “Quickstart” section at the end of the <a href='http://llvm.org/docs/GoldPlugin.html'>LLVM plugin page</a> gives you the outline. I use SCons as my build tool, so I have to run the following:</p>

<pre><code>$ scons \
    CC=&quot;llvm-gcc -use-gold-plugin&quot; \
    AR=&quot;ar --plugin libLLVMgold.so&quot; \
    RANLIB=/bin/true \
    CCFLAGS=-O4</code></pre>

<p>This is slightly more than what&#8217;s needed on the Mac, but all in all, not bad. Enjoy!</p>

  
  <div class="posttags">
    Tags:
    <ul>
      
      <li><a href="/tags/ubuntu/">ubuntu</a></li>
      
      <li><a href="/tags/llvm/">llvm</a></li>
      
    </ul>
  </div>
  

  <div class="postlinks">
    <a href="/2010/02/17/llvm-lto-karmic/">Permanent link</a>
    |
    <a href="/2010/02/17/llvm-lto-karmic/#disqus_thread">Comments</a>
  </div>


        </div>

        <script type="text/javascript"> Cufon.now(); </script>

        

        </div>

      </div>
    </div>

    <div class="footer">
      <div class="copyright">
        Copyright © 2009-2010, Douglas Creager.  All rights reserved.
      </div>
    </div>
  </body>
</html>

